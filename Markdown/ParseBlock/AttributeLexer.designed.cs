//------------------------------------------------------------------------------
// <auto-generated>
// 此代码由工具生成。
//
// 对此文件的更改可能会导致不正确的行为，并且如果
// 重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

using System.Collections.Generic;
using System.Globalization;
using System.Runtime.CompilerServices;
using Cyjb.Compilers.Lexers;

namespace Cyjb.Markdown.ParseBlock;

internal partial class AttributeLexer 
{
	/// <summary>
	/// 词法分析器的工厂。
	/// </summary>
	[CompilerGeneratedAttribute]
	public static readonly ILexerFactory<AttributeKind> Factory = CreateLexerFactory();

	/// <summary>
	/// 创建词法分析器的工厂。
	/// </summary>
	[CompilerGeneratedAttribute]
	private static ILexerFactory<AttributeKind> CreateLexerFactory()
	{
		// 终结符数据
		TerminalData<AttributeKind>[] terminals = new[]
		{
			// 0: #{Name}
			new TerminalData<AttributeKind>(AttributeKind.Identifier, action: (AttributeLexer c) => c.IdentifierOrClassNameAction()),
			// 1: \.{Name}
			new TerminalData<AttributeKind>(AttributeKind.ClassName, action: (AttributeLexer c) => c.IdentifierOrClassNameAction()),
			// 2: {AttrName}
			new TerminalData<AttributeKind>(AttributeKind.Common, action: (AttributeLexer c) => c.NoValueAttributeAction()),
			// 3: {AttrName}={AttrValue}
			new TerminalData<AttributeKind>(AttributeKind.Common, action: (AttributeLexer c) => c.QuotedValueAttributeAction()),
			// 4: {AttrName}=[^ \t\r\n\"'=<>`{}]+
			new TerminalData<AttributeKind>(AttributeKind.Common, action: (AttributeLexer c) => c.UnquotedValueAttributeAction()),
			// 5: [ \t\r\n]+
			new TerminalData<AttributeKind>(AttributeKind.Seperator, action: (AttributeLexer c) => c.SeperatorAction()),
			// 6: \}
			new TerminalData<AttributeKind>(action: (AttributeLexer c) => c.EndAction()),
			// 7: .
			new TerminalData<AttributeKind>(AttributeKind.Invalid, action: (AttributeLexer c) => c.InvalidAction())
		};
		// 字符类信息
		//  0: [#]
		//  1: [!$-&(-,/;?@[-^|~\u00A0-\uFFFE\p{Cc}-[\t\n\r]]
		//  2: [.]
		//  3: [:A-Z_a-z]
		//  4: [-0-9]
		//  5: [=]
		//  6: [']
		//  7: [<>`{]
		//  8: ["]
		//  9: [\n\r]
		// 10: [\t ]
		// 11: [}]
		// 字符类索引
		uint[] indexes = new[]
		{
			10551294U
		};
		// 字符类列表
		int[] classes = new[]
		{
			1, 1, 1, 1, 1, 1, 1, 1, 1, 10, 9, 1, 1, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			1, 1, 1, 1, 1, 1, 1, 1, 10, 1, 8, 0, 1, 1, 1, 6, 1, 1, 1, 1, 1, 4, 2, 1,
			4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 1, 7, 5, 7, 1, 1, 3, 3, 3, 3, 3, 3, 3,
			3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 3,
			7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
			3, 3, 3, 7, 1, 11, 1, 1, 1
		};
		// 字符类 Unicode 类别
		Dictionary<UnicodeCategory, int> categories = new()
		{
			 { UnicodeCategory.Control, 1 }
		};
		// 状态转移
		//      0   1   2   3   4   5   6   7   8  9  10  11 -> Symbols
		//  0   1   2   3   4   2   2   2   2   2  5   5   6
		//  1  13  13  13  13  13                            -> 7
		//  2                                                -> 7
		//  3  12  12  12  12  12                            -> 7
		//  4           4   4   4   7                        -> 2 conflict 7
		//  5                                      5   5     -> 5
		//  6                                                -> 6 conflict 7
		//  7   8   8   8   8   8       9      10           
		//  8   8   8   8   8   8                            -> 4
		//  9   9   9   9   9   9   9  11   9   9      9   9
		// 10  10  10  10  10  10  10  10  10  11     10  10
		// 11                                                -> 3
		// 12  12  12  12  12  12                            -> 1
		// 13  13  13  13  13  13                            -> 0
		// 状态列表
		int[] states = new[]
		{
			0, -1, 0, 0, 12, -1, 1, 56,
			short.MinValue, -1, 1, 56, 17, -1, 1, 56,
			20, -1, 1, 57, 17, -1, 1, 58,
			short.MinValue, -1, 1, 59, 28, -1, 0, 0,
			37, -1, 1, 60, 42, -1, 0, 0,
			54, -1, 0, 0, short.MinValue, -1, 1, 61,
			short.MinValue, 3, 1, 62, short.MinValue, 1, 1, 63,
			7, 2, 5, 6, 4, 3, 1, 0
		};
		// 状态转移
		int[] trans = new[]
		{
			0, 1, 0, 2, 0, 3, 0, 4, 0, 2, 0, 2,
			0, 2, 0, 2, 0, 2, 0, 5, 0, 5, 0, 6,
			1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 12,
			3, 12, 3, 12, 3, 12, 3, 12, 4, 4, 4, 4,
			4, 4, 4, 7, 5, 5, 5, 5, 7, 8, 7, 8,
			7, 8, 7, 8, 7, 8, -1, -1, 7, 9, -1, -1,
			7, 10, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
			9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
			9, 11, 9, 9, 9, 9, -1, -1, 9, 9, 9, 9,
			10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
			10, 10, 10, 10, 10, 11, -1, -1, 10, 10, 10, 10
		};
		// 词法分析器的数据
		LexerData<AttributeKind> lexerData = new(null,
			terminals,
			new CharClassMap(indexes, classes, categories),
			states,
			trans,
			TrailingType.None,
			false,
			false,
			typeof(AttributeLexer));
		return new LexerFactory<AttributeKind, AttributeLexer>(lexerData);
	}
}



